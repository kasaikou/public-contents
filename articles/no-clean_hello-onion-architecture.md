---
title: クリーンアーキわからんかった人のためのオニオンアーキテクチャ
emoji: 🧅
type: tech
topics: [クリーンアーキテクチャ, オニオンアーキテクチャ, 設計, DDD]
published: false
---

# 依存関係逆転の法則に苦しんだ方々、いかがお過ごしでしょうか。
今回はアプリ設計の話です。
アプリ設計におけるクリーンアーキテクチャについて少し語り、調べていくうえで誤解していた部分や理解しにくかった部分を語ったうえで、オニオンアーキテクチャとクリーンアーキテクチャというよく似た二種類のアーキテクチャの説明をしていく、という流れとなっています。

:::message alert
かなり経験からの持論があるのでめちゃくちゃ有識者の方の意見聞きたい気持ちがすごい
:::

## 言葉の定義について

ここではアーキテクチャにおけるインターフェイスとプログラミング言語におけるインターフェイスを区別するために、プログラミング言語におけるインターフェイスを**抽象型**と表記します。

> それぞれの言語において、抽象型は以下のような言語機能で実現されています[^1]。
> - Java, C#などにおける抽象クラス `abstract class`
> - Java, C#, Golangなどにおけるインターフェイス `interface`
> - rustにおけるトレイト `trait`
> - Pythonにおける抽象基底クラス `abstract base class`
> - C++における純粋仮想関数 `pure virtual function`
:::message
言語によっては抽象クラスとインターフェイスが別々に用意されている場合がありますが、今回は区別しません。
:::

抽象型は同様のメソッドを持つオブジェクトの集まりという感じのイメージです。
それ単体では動作せず、抽象型に示された条件を満たすオブジェクト（構造体やクラスなど）を代入することで動作できる、という特徴を持っています。詳しくはググってください。

[^1]: 作るデータ構造や利用の仕方によっては必ずしも抽象型を使用しなくてもよい場合があります。例えば、C++20のコンセプトによるテンプレートパラメータの制約やC言語のヘッダ/ソースを用いた宣言と実装の分離でも解決できる場合があります。しかし、そういう事例を小分けにすると面倒なので全部一括りで抽象型と表記します。

## 参考にしたもののエトセトラ
基本的には自分の経験と、執筆時に改めて参考にした記事です。
- [クリーンアーキテクチャ完全に理解した](https://gist.github.com/mpppk/609d592f25cab9312654b39f1b357c60)
    - ここでは厳密に4層を定義する狭義のクリーンアーキテクチャと目的とその手法だけを理解して定義する広義のクリーンアーキテクチャのうち、前者について語っています。この記事では前半だけ前者を扱い、後者の方を扱います。
    - 思うに、会話で使用されるのは前者ですが実際に前者で厳密に定義されているのはごくわずかな気がします。
- [オニオンアーキテクチャとは何か](https://qiita.com/cocoa-maemae/items/e3f2eabbe0877c2af8d0)

# クリーンアーキテクチャとは
## その目的
はじめは、なぜクリーンアーキテクチャを使いたいのか、ということを考えます。大きく分けて以下の2個に分類されます。
- 各モジュールにおける関心事を限定する
- 依存関係をよりシンプルなものにする
一つ一つその意味を確認していきます。

### 各モジュールにおける関心事を限定する
大きなプログラムを作るとき、「データベースに接続するモジュール」「特定のビジネスルールを実行するモジュール」という風に大きな問題を小さな話題に分割し、他の要素を排除していく、という考え方をしていきます。
簡単な例（大規模であればあるほどクリーンアーキテクチャとしてのメリットが大きくなるので、あまりいい例ではない）を示します。
```mermaid
flowchart LR
subgraph 結果を管理するモジュール
save1[結果をデータベースに保存]
show1[結果を画面に表示]
end
subgraph 履歴を管理するモジュール 
save2[履歴をデータベースに保存]
show2[履歴を画面に表示]
end
```

みたいなモジュールがあったときに、表示方法をする場合、各モジュールで画面への表示方法を変えなければいけないわけです。この例ではUIの例ですが、フレームワークやテスト、データベースなどの外界と実際のアプリケーションが分割されるようなプロダクトを作ることで、より効率的な開発を行うことができます。

> 実際、クリーンアーキテクチャではユースケース層（ビジネスクロック）はインフラストラクチャ層に依存しないのでユースケース層は自分が出した結果が抽象型を用いて保存されていることを知っていても、それがデータベースへの保存なのか、テキストファイルへの保存なのか、あるいは保存されてすらいないのかは知ることはありませんし、責任を持つこともありません。

### 依存関係をよりシンプルなものにする
![](https://storage.googleapis.com/zenn-user-upload/c0231396c6677cb52e3a9640.png)

クリーンアーキテクチャを調べた方なら皆さんもこれは見たことあるでしょう。このグラフです。よく右下にあるグラフのほうが大事といわれます（実際に大事）が、今大事なのは左側の円と左側の矢印です。
これは狭義の意味になりますが、要するに、**外側から内側への一方向にのみ依存していく**ということです。外側はフレームワークやドライバーから、ビジネスクロックなどを含むユースケース層、データ構造などを含むエンティティ層と向かっていきます。**具体的なところから抽象的となる方向に向かって依存していく**とも言い換えられます、それだけです。「で？」という気持ちはわかります（実際にボクもなった）が、具体的な実装方法は説明します。

## 基本方針
では、前述したような目的を達成していくための方針をここでまとめておきます。


# クリーンアーキテクチャのわかりにくいところ
基本的に自分が躓いたところについて解説していきます。

## アーキテクチャのインターフェイスと言語機能のインターフェイスは違う
多分ボクが一番苦しんだところかもしれない笑
アーキテクチャのインターフェイスはユースケース層とインフラストラクチャ層を変換するエリアであり、**変換することに注目した関数や構造体などの独立したモジュール**です。あくまでも言語機能のインターフェイスではないことを意識しておいてください。
:::message
これらを区別する必要があるので、この記事では言語機能のインターフェイスを**抽象型**と呼ぶこととします。
:::

## 「フレームワーク」「ドライバ」は大抵ライブラリとして提供されている事実
インフラストラクチャ内に含まれているフレームワーク・ドライバはSQLであればSQLの、GPUであればGPUのライブラリがそれぞれ提供されています。これを一から作るのはあほです。当然流用します。
しかし、流用しようとすると大きな問題が発生します。エントリポイント以外ではインフラストラクチャ層からインターフェイス層を呼び出す手立てがありません（エントリポイント自体がインターフェイスに属するという意見も聞くので一概に言えませんが）。これはつまり、**どうやってもインフラストラクチャ層はインターフェイス層を呼び出すことはできません**。インターフェイスからインフラストラクチャ層を呼ばなければいけないということです。このため、言葉ではクリーンアーキテクチャと言っても実際に厳格なクリーンアーキテクチャを実装しているケースは少ないです。
:::message alert
しかし、このような文句・苦情を想定してか、クリーンアーキテクチャにおけるインフラストラクチャ層には`Adapter`や`Translator`という形でより抽象的なところで使用する形に変換する場合があります。これがまた状況をごちゃごちゃにしていきます。
:::
```mermaid
flowchart LR;
subgraph 理想的なクリーンアーキテクチャ
direction LR
1[インフラストラクチャ層] --> 2[インターフェイス層] -->3[ユースケース層] --> 4[エンティティ層]
end
subgraph 実際のクリーンアーキテクチャ
direction LR
5[インターフェイス層] --> 6[インフラストラクチャ層]
5 --> 7[ユースケース層] --> 8[エンティティ層]
end
```

# インフラストラクチャ層とインターフェイス層の違いって何ですか？
一応、定義をもう一度確認しておきます。
- インフラストラクチャ層はデバイスや実行環境のドライバやフレームワーク
- インターフェイス層はユースケース層とインフラストラクチャ層の相互変換を行う

しかし、フレームワークやドライバはすでに既存のものを使うことが大半です。また、クリーンアーキテクチャにおいてインフラストラクチャ層の変更（特に使用する外部環境の交換）はそれにインターフェイス層の変更によってユースケース層への影響を緩和することで解決します。
つまり、インフラストラクチャ層の変更とインターフェイス層の変更はおよそリンクしているのです。

# オニオンアーキテクチャの提案
![](https://storage.googleapis.com/zenn-user-upload/44895c5f90f3330c7d07d296.png)
ここで、ボクはオニオンアーキテクチャを提案します。**やっていることそれ自体はあまり変わりません**。大事なことなので二度言います。**やっていることそれ自体はクリーンアーキテクチャと大差ありません**。

## 実際の実装方法
ドメインモデル層、ドメインサービス層、アプリケーションサービス層、インフラストラクチャ層の4層に分割して、以下の方針で実装します。
- **ドメインモデル層**はデータ構造に焦点を当てて実装します
- **ドメインサービス層**は実装する必要はありませんが、**インフラストラクチャ層やアプリケーションサービス層で実装するべき機能を抽象型でまとめておきます**。この抽象型はアプリケーションサービス層がインフラストラクチャ層を呼ぶときに使用し、引数にはエンティティ層で使用しているデータ型やそのメンバー型であるべきです。
- **アプリケーションサービス層**はそれぞれ**ビジネスクロックを定義すること**に焦点を当てて実装します。ドメインモデル層のデータ構造を使い、ドメインサービス層で定義された抽象型からインフラストラクチャ層のモジュールや他のアプリケーションサービスのモジュールを扱います。
- **インフラストラクチャ層**では、**ドライバやフレームワークを利用し、ユースケース層で使用するデータ構造に変換**、またはその逆である**ユースケース層からのデータをドライバやフレームワークを利用するための変換**に焦点を当てて実装します。この時、ドメインサービス層で定義した抽象型に沿うように設計します。
    - このとき、エントリポイントはインフラストラクチャ層に配置し、インフラストラクチャ層の初期化を行ってからアプリケーションサービス層に自身を含むインフラストラクチャ層のモジュールをドメインサービス層で定義した抽象型として渡します。

ドライバやフレームワークの変更を行ったとしてもユースケース層の抽象型を満たすインフラストラクチャ層のモジュールを作ることでユースケース層は変えずに済むことができます。

## クリーンアーキテクチャとの違い
本質的な違いはありません。命名とその説明方法の差異が一番大きいと思っています。

| クリーンアーキテクチャのおける概念 | オニオンアーキテクチャにおける概念 |
| :-: | :-: |
| エンティティ層 | ドメインモデル層 |
| （エンティティまたはユースケース層） | ドメインサービス層 |
| ユースケース層 | アプリケーションサービス層 |
| インターフェイス層 | インフラストラクチャ層 |
| インフラストラクチャ層 | （外界扱い） |

# おわりに
いかがだったでしょうか。多分言いたいことは全部言った気がします。クリーンアーキテクチャの考え方で実装しにくいと思ったら、一度クリーンアーキテクチャで実装してみるのが良いと思います。

## 最後に宣伝
「適度にもくもく、適度に駄弁る。」をテーマにしたもくもく会を開催したいと画策しているのですが、なかなか人を集めるのが大変なのでぜひぜひ参加していただけると助かります。

